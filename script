-- UTG (Special edition)
-- Made by GoldGowd

-- Instances:

local ScreenGui = Instance.new("ScreenGui")
local MainFrame = Instance.new("ImageLabel")
local UIGradient = Instance.new("UIGradient")
local Title = Instance.new("TextLabel")
local Credit = Instance.new("TextLabel")
local Frame = Instance.new("Frame")
local Frame_2 = Instance.new("Frame")
local Close = Instance.new("TextButton")
local sonic = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")
local chathax = Instance.new("TextButton")
local UICorner_2 = Instance.new("UICorner")
local Krystaldance = Instance.new("TextButton")
local UICorner_3 = Instance.new("UICorner")
local GaleFighter = Instance.new("TextButton")
local UICorner_4 = Instance.new("UICorner")
local Domainx = Instance.new("TextButton")
local UICorner_5 = Instance.new("UICorner")
local Imagefolder = Instance.new("ImageLabel")
local Open = Instance.new("TextButton")
local UICorner_6 = Instance.new("UICorner")
local UIGradient_2 = Instance.new("UIGradient")
local Label = Instance.new("TextLabel")
local R6 = Instance.new("TextButton")
local UICorner_7 = Instance.new("UICorner")
local UIGradient_3 = Instance.new("UIGradient")

--Properties:

ScreenGui.Parent = game.CoreGui

MainFrame.Name = "MainFrame"
MainFrame.Parent = ScreenGui
MainFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
MainFrame.BackgroundTransparency = 1.000
MainFrame.Position = UDim2.new(0.291355342, 0, 0.0656814426, 0)
MainFrame.Size = UDim2.new(0, 310, 0, 484)
MainFrame.Image = "rbxassetid://3570695787"
MainFrame.ScaleType = Enum.ScaleType.Slice
MainFrame.SliceCenter = Rect.new(100, 100, 100, 100)
MainFrame.SliceScale = 0.120

UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(143, 5, 255)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 6, 231))}
UIGradient.Rotation = 20
UIGradient.Parent = MainFrame

Title.Name = "Title"
Title.Parent = MainFrame
Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Title.BackgroundTransparency = 1.000
Title.Position = UDim2.new(0.00967741944, 0, 0, 0)
Title.Size = UDim2.new(0, 304, 0, 50)
Title.Font = Enum.Font.SciFi
Title.Text = "UTG Special Edition"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 29.000

Credit.Name = "Credit"
Credit.Parent = MainFrame
Credit.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Credit.BackgroundTransparency = 1.000
Credit.BorderSizePixel = 0
Credit.Position = UDim2.new(0, 0, 0.896694243, 0)
Credit.Size = UDim2.new(0, 310, 0, 39)
Credit.Font = Enum.Font.SciFi
Credit.Text = "Made By GoldGowd#0985"
Credit.TextColor3 = Color3.fromRGB(255, 255, 255)
Credit.TextSize = 24.000

Frame.Parent = MainFrame
Frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Frame.BorderColor3 = Color3.fromRGB(255, 255, 255)
Frame.Position = UDim2.new(0, 0, 0.103305787, 0)
Frame.Size = UDim2.new(0, 310, 0, 0)

Frame_2.Parent = MainFrame
Frame_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Frame_2.BorderColor3 = Color3.fromRGB(255, 255, 255)
Frame_2.Position = UDim2.new(0, 0, 0.896694243, 0)
Frame_2.Size = UDim2.new(0, 310, 0, 0)

Close.Name = "Close"
Close.Parent = MainFrame
Close.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Close.BackgroundTransparency = 1.000
Close.BorderSizePixel = 0
Close.Position = UDim2.new(0.851612926, 0, 0, 0)
Close.Size = UDim2.new(0, 40, 0, 50)
Close.Font = Enum.Font.SciFi
Close.Text = "X"
Close.TextColor3 = Color3.fromRGB(255, 255, 255)
Close.TextSize = 30.000

sonic.Name = "sonic"
sonic.Parent = MainFrame
sonic.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
sonic.BorderSizePixel = 0
sonic.Position = UDim2.new(0.167741939, 0, 0.128099173, 0)
sonic.Size = UDim2.new(0, 200, 0, 50)
sonic.Font = Enum.Font.SciFi
sonic.Text = "Sonic"
sonic.TextColor3 = Color3.fromRGB(0, 0, 0)
sonic.TextSize = 20.000

UICorner.CornerRadius = UDim.new(0, 7)
UICorner.Parent = sonic

chathax.Name = "chathax"
chathax.Parent = MainFrame
chathax.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
chathax.Position = UDim2.new(0.167741895, 0, 0.274793357, 0)
chathax.Size = UDim2.new(0, 200, 0, 50)
chathax.Font = Enum.Font.SciFi
chathax.Text = "Chat hack"
chathax.TextColor3 = Color3.fromRGB(0, 0, 0)
chathax.TextSize = 20.000

UICorner_2.CornerRadius = UDim.new(0, 7)
UICorner_2.Parent = chathax

Krystaldance.Name = "Krystaldance"
Krystaldance.Parent = MainFrame
Krystaldance.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Krystaldance.Position = UDim2.new(0.16774188, 0, 0.427685916, 0)
Krystaldance.Size = UDim2.new(0, 200, 0, 50)
Krystaldance.Font = Enum.Font.SciFi
Krystaldance.Text = "Krystal dance"
Krystaldance.TextColor3 = Color3.fromRGB(0, 0, 0)
Krystaldance.TextSize = 20.000

UICorner_3.CornerRadius = UDim.new(0, 7)
UICorner_3.Parent = Krystaldance

GaleFighter.Name = "GaleFighter"
GaleFighter.Parent = MainFrame
GaleFighter.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
GaleFighter.BorderSizePixel = 0
GaleFighter.Position = UDim2.new(0.167741895, 0, 0.745867789, 0)
GaleFighter.Size = UDim2.new(0, 200, 0, 50)
GaleFighter.Font = Enum.Font.SciFi
GaleFighter.Text = "Gale Fighter"
GaleFighter.TextColor3 = Color3.fromRGB(0, 0, 0)
GaleFighter.TextSize = 20.000

UICorner_4.CornerRadius = UDim.new(0, 7)
UICorner_4.Parent = GaleFighter

Domainx.Name = "Domainx"
Domainx.Parent = MainFrame
Domainx.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Domainx.Position = UDim2.new(0.167741939, 0, 0.584710717, 0)
Domainx.Size = UDim2.new(0, 200, 0, 50)
Domainx.Font = Enum.Font.SciFi
Domainx.Text = "Domain X"
Domainx.TextColor3 = Color3.fromRGB(0, 0, 0)
Domainx.TextSize = 20.000

UICorner_5.CornerRadius = UDim.new(0, 7)
UICorner_5.Parent = Domainx

Imagefolder.Name = "Image folder"
Imagefolder.Parent = MainFrame
Imagefolder.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Imagefolder.BackgroundTransparency = 1.000
Imagefolder.Position = UDim2.new(0.0354838707, 0, 0.0206611566, 0)
Imagefolder.Size = UDim2.new(0, 30, 0, 32)
Imagefolder.Image = "http://www.roblox.com/asset/?id=8756129246"

Open.Name = "Open"
Open.Parent = ScreenGui
Open.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Open.Position = UDim2.new(0.807897568, 0, 0.878489316, 0)
Open.Size = UDim2.new(0, 137, 0, 50)
Open.Font = Enum.Font.SciFi
Open.Text = "Open"
Open.TextColor3 = Color3.fromRGB(0, 0, 0)
Open.TextSize = 20.000

UICorner_6.CornerRadius = UDim.new(0, 7)
UICorner_6.Parent = Open

UIGradient_2.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(119, 0, 255)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(247, 0, 255))}
UIGradient_2.Parent = Open

Label.Name = "Label"
Label.Parent = ScreenGui
Label.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Label.BackgroundTransparency = 1.000
Label.BorderSizePixel = 0
Label.Position = UDim2.new(0.0576307327, 0, 0.935960591, 0)
Label.Size = UDim2.new(0, 174, 0, 32)
Label.Font = Enum.Font.SciFi
Label.Text = "Currently its not done"
Label.TextColor3 = Color3.fromRGB(0, 0, 0)
Label.TextSize = 30.000

R6.Name = "R6"
R6.Parent = ScreenGui
R6.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
R6.Position = UDim2.new(0.807897568, 0, 0.755336583, 0)
R6.Size = UDim2.new(0, 137, 0, 50)
R6.Font = Enum.Font.SciFi
R6.Text = "R6"
R6.TextColor3 = Color3.fromRGB(0, 0, 0)
R6.TextSize = 20.000

UICorner_7.CornerRadius = UDim.new(0, 7)
UICorner_7.Parent = R6

UIGradient_3.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(119, 0, 255)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(247, 0, 255))}
UIGradient_3.Parent = R6

-- Module Scripts:

local fake_module_scripts = {}

do -- R6.R6
	local script = Instance.new('ModuleScript', R6)
	script.Name = "R6"
	local function module_script()
		local R6Converter = {}
		function R6Converter.load(Plr)
		Plr = game.Players:WaitForChild(Plr)
		local FalseChar = script:WaitForChild("DefaultCharacter"):Clone()
		local PlayersCharacter = game.Players:GetCharacterAppearanceAsync(Plr.UserId):Clone()
		local FaceID = (Plr.Character:WaitForChild("Head"):FindFirstChild("face") or {Texture = "http://www.roblox.com/asset/?id=144080495"}).Texture
		local Accessories = {}
		FalseChar:WaitForChild("Head"):WaitForChild("face").Texture = FaceID
		FalseChar:SetPrimaryPartCFrame(Plr.Character:WaitForChild("HumanoidRootPart").CFrame)
		for _,Prt in pairs(PlayersCharacter:GetDescendants()) do
		if Prt:IsA("Accessory") or Prt:IsA("Hat") or Prt:IsA("BodyColors") or Prt:IsA("CharacterMesh")or Prt:IsA("Pants") or Prt:IsA("Shirt") or Prt:IsA("ShirtGraphic") or Prt:IsA("Tool") then
		table.insert(Accessories,Prt:Clone())
		end
		end
		
		for _,Prt in pairs(Plr.Character:GetChildren()) do
		Prt:Destroy()
		end
		for _,Prt in pairs(FalseChar:GetChildren()) do
		Prt.Parent = Plr.Character
		end
		for _,Prt in pairs(Accessories) do
		Prt.Parent = Plr.Character
		end
		
		
		end
		
		return R6Converter
		
	end
	fake_module_scripts[script] = module_script
end


-- Scripts:

local function BCZQV_fake_script() -- Close.LocalScript 
	local script = Instance.new('LocalScript', Close)
	local req = require
	local require = function(obj)
		local fake = fake_module_scripts[obj]
		if fake then
			return fake()
		end
		return req(obj)
	end

	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Visible = false
	end)
end
coroutine.wrap(BCZQV_fake_script)()
local function BZMVXPS_fake_script() -- sonic.LocalScript 
	local script = Instance.new('LocalScript', sonic)
	local req = require
	local require = function(obj)
		local fake = fake_module_scripts[obj]
		if fake then
			return fake()
		end
		return req(obj)
	end

	script.MouseButton1Down:connect(function()
		-- This script has been converted to FE by iPxter
	
	
		if game:GetService("RunService"):IsClient() then error("Script must be server-side in order to work; use h/ and not hl/") end
		local Player,Mouse,mouse,UserInputService,ContextActionService = owner
		do
			print("FE Compatibility code by Mokiros | Translated to FE by iPxter")
			script.Parent = Player.Character
	
			--RemoteEvent for communicating
			local Event = Instance.new("RemoteEvent")
			Event.Name = "UserInput_Event"
	
			--Fake event to make stuff like Mouse.KeyDown work
			local function fakeEvent()
				local t = {_fakeEvent=true,Connect=function(self,f)self.Function=f end}
				t.connect = t.Connect
				return t
			end
	
			--Creating fake input objects with fake variables
			local m = {Target=nil,Hit=CFrame.new(),KeyUp=fakeEvent(),KeyDown=fakeEvent(),Button1Up=fakeEvent(),Button1Down=fakeEvent()}
			local UIS = {InputBegan=fakeEvent(),InputEnded=fakeEvent()}
			local CAS = {Actions={},BindAction=function(self,name,fun,touch,...)
				CAS.Actions[name] = fun and {Name=name,Function=fun,Keys={...}} or nil
			end}
			--Merged 2 functions into one by checking amount of arguments
			CAS.UnbindAction = CAS.BindAction
	
			--This function will trigger the events that have been :Connect()'ed
			local function te(self,ev,...)
				local t = m[ev]
				if t and t._fakeEvent and t.Function then
					t.Function(...)
				end
			end
			m.TrigEvent = te
			UIS.TrigEvent = te
	
			Event.OnServerEvent:Connect(function(plr,io)
				if plr~=Player then return end
				if io.isMouse then
					m.Target = io.Target
					m.Hit = io.Hit
				else
					local b = io.UserInputState == Enum.UserInputState.Begin
					if io.UserInputType == Enum.UserInputType.MouseButton1 then
						return m:TrigEvent(b and "Button1Down" or "Button1Up")
					end
					for _,t in pairs(CAS.Actions) do
						for _,k in pairs(t.Keys) do
							if k==io.KeyCode then
								t.Function(t.Name,io.UserInputState,io)
							end
						end
					end
					m:TrigEvent(b and "KeyDown" or "KeyUp",io.KeyCode.Name:lower())
					UIS:TrigEvent(b and "InputBegan" or "InputEnded",io,false)
				end
			end)
			Event.Parent = NLS([==[
		local Player = owner
		local Event = script:WaitForChild("UserInput_Event")
	
		local UIS = game:GetService("UserInputService")
		local input = function(io,a)
			if a then return end
			--Since InputObject is a client-side instance, we create and pass table instead
			Event:FireServer({KeyCode=io.KeyCode,UserInputType=io.UserInputType,UserInputState=io.UserInputState})
		end
		UIS.InputBegan:Connect(input)
		UIS.InputEnded:Connect(input)
	
		local Mouse = owner
		local h,t
		--Give the server mouse data 30 times every second, but only if the values changed
		--If player is not moving their mouse, client won't fire events
		while wait(1/30) do
			if h~=Mouse.Hit or t~=Mouse.Target then
				h,t=Mouse.Hit,Mouse.Target
				Event:FireServer({isMouse=true,Target=t,Hit=h})
			end
		end]==],Player.Character)
			Mouse,mouse,UserInputService,ContextActionService = m,m,UIS,CAS
		end
		--[[KillerDarkness0105's/Codex's Sonic script]]--
	
	
	
		wait(0.07)
		Player=owner
		Character=Player.Character
		PlayerGui=Player.PlayerGui
		Backpack=Player.Backpack
		Torso=Character.Torso
		Head=Character.Head
		Humanoid=Character.Humanoid
		LeftArm=Character["Left Arm"]
		LeftLeg=Character["Left Leg"]
		RightArm=Character["Right Arm"]
		RightLeg=Character["Right Leg"]
		LS=Torso["Left Shoulder"]
		LH=Torso["Left Hip"]
		RS=Torso["Right Shoulder"]
		RH=Torso["Right Hip"]
		Face = Head.face
		Neck=Torso.Neck
		it=Instance.new
		attacktype=1
		attacktype2=1
		vt=Vector3.new
		cf=CFrame.new
		cn=CFrame.new
		euler=CFrame.fromEulerAnglesXYZ
		angles=CFrame.Angles
		combo = 0
		necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
		necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
		LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
		LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
		RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
		RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
		RootPart=Character.HumanoidRootPart
		RootJoint=RootPart.RootJoint
		RootCF=euler(-1.57,0,3.14)
		attack = false
		attackdebounce = false
		trispeed=.2
		attackmode='none'
		local idle=0
		local Anim="Idle"
		stance = false
		local ff = 2
		noleg = false
		evadecooldown = false
		Humanoid.Animator.Parent = nil
		equip = false
		local Effects = {}
		attackspeed = 0.14 
		df = false
		Swing = 1
		local sine = 0
		local change = 1
		local val = 0
		local speed = 0
		local rs = game:GetService("RunService").RenderStepped
		cam = workspace.CurrentCamera
		local RbxUtility = LoadLibrary("RbxUtility")
		local Create = RbxUtility.Create
		deb = game:GetService("Debris")
		Face.Transparency = 0
		--Face.Texture = "rbxassetid://176217905" --176217905
		Humanoid.WalkSpeed = 64
		local freefall = 0
		Head.Running.SoundId = "rbxassetid://758199523"
		Head.Running.Volume = 2
		local boost = false
		Humanoid.JumpPower = 88
		local musicnum = 1
	
		local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude + 10
		local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
		local GravPoint = RootPart.Velocity.y
		local NV = Vector3.new(0,0,0)
		print("Move list")
		print("---------")
		print("Shift = Boost")
		print("Ctrl = Mach Speed Boost")
		print("Q = Left QuickStep, E  = Right QuickStep")
		print("C = Slide, in air to stomp")
		print("Jump Then Hold B near a wall to wallrun")
		print("M to change music, if you're standing still you'll do a special animation!")
		print("Space near a wall to walljump, away from a wall homing attack")
		music = Instance.new("Sound",PlayerGui)
		music.Volume = 1
		music.TimePosition = 0
		music.Pitch = 1
		music.SoundId = "rbxassetid://1251555494"
		music.Looped = true
		music:Play()
	
	
		boostsound = Instance.new("Sound",PlayerGui)
		boostsound.Volume = .6
		boostsound.TimePosition = 0
		boostsound.Pitch = 1
		boostsound.SoundId = "rbxassetid://924922553"
		boostsound.Looped = false
	
	
	
		stompsound = Instance.new("Sound",PlayerGui)
		stompsound.Volume = 2
		stompsound.TimePosition = 0
		stompsound.Pitch = 1
		stompsound.SoundId = "rbxassetid://1295424184"
		stompsound.Looped = false
	
	
	
		so = function(id,par,vol,pit)
			coroutine.resume(coroutine.create(function()
				local sou = Instance.new("Sound",par or workspace)
				sou.Volume=vol
				sou.Pitch=pit or 1
				sou.SoundId=id
				sou:play()
				game:GetService("Debris"):AddItem(sou,8)
			end))
		end
	
		--save shoulders
		RSH, LSH=nil, nil
		--welds
		RW, LW=Instance.new("Weld"), Instance.new("Weld")
		RW.Name="Right Shoulder" LW.Name="Left Shoulder"
		LH=Torso["Left Hip"]
		RH=Torso["Right Hip"]
		TorsoColor=Torso.BrickColor
		function NoOutline(Part)
			Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
		end
		player=Player
		ch=Character
		RSH=ch.Torso["Right Shoulder"]
		LSH=ch.Torso["Left Shoulder"]
		--
		RSH.Parent=nil
		LSH.Parent=nil
		--
		RW.Name="Right Shoulder"
		RW.Part0=ch.Torso
		RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5)
		RW.C1=cf(0, 0.5, 0)
		RW.Part1=ch["Right Arm"]
		RW.Parent=ch.Torso
		--
		LW.Name="Left Shoulder"
		LW.Part0=ch.Torso
		LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8)
		LW.C1=cf(0, 0.5, 0)
		LW.Part1=ch["Left Arm"]
		LW.Parent=ch.Torso
	
	
		newWeld = function(wp0, wp1, wc0x, wc0y, wc0z)
			local wld = Instance.new("Weld", wp1)
			wld.Part0 = wp0
			wld.Part1 = wp1
			wld.C0 = CFrame.new(wc0x, wc0y, wc0z)
		end
		local rs = game:GetService("RunService").RenderStepped
	
		newWeld(RootPart, Torso, 0, -1, 0)
		Torso.Weld.C1 = CFrame.new(0, -1, 0)
		newWeld(Torso, LeftLeg, -0.5, -1, 0)
		LeftLeg.Weld.C1 = CFrame.new(0, 1, 0)
		newWeld(Torso, RightLeg, 0.5, -1, 0)
		RightLeg.Weld.C1 = CFrame.new(0, 1, 0)
	
		Player=owner
		Character=Player.Character
		mouse=Player:GetMouse()
		m=Instance.new('Model',Character)
	
	
		local function weldBetween(a, b)
			local weldd = Instance.new("ManualWeld")
			weldd.Part0 = a
			weldd.Part1 = b
			weldd.C0 = CFrame.new()
			weldd.C1 = b.CFrame:inverse() * a.CFrame
			weldd.Parent = a
			return weldd
		end
	
		ArtificialHB = Instance.new("BindableEvent", script)
		ArtificialHB.Name = "Heartbeat"
	
		script:WaitForChild("Heartbeat")
	
		frame = 1 / 80
		tf = 0
		allowframeloss = false
		tossremainder = false
		lastframe = tick()
		script.Heartbeat:Fire()
		game:GetService("RunService").Heartbeat:connect(function(s, p)
			tf = tf + s
			if tf >= frame then
				if allowframeloss then
					script.Heartbeat:Fire()
					lastframe = tick()
				else
					for i = 1, math.floor(tf / frame) do
						script.Heartbeat:Fire()
					end
					lastframe = tick()
				end
				if tossremainder then
					tf = 0
				else
					tf = tf - frame * math.floor(tf / frame)
				end
			end
		end)
	
	--[[]
			function swait(num)
			    if num == 0 or num == nil then
			        ArtificialHB.Event:wait()
			    else
			        for i = 0, num do
			            ArtificialHB.Event:wait()
			        end
			    end
		end
	
		]]
	
	
	
	
		function swait(num)
			if num == 0 or num == nil then
				game:service("RunService").Stepped:wait()
			else
				for i = 0, num do
					game:service("RunService").Stepped:wait()
				end
			end
		end
	
		function RemoveOutlines(part)
			part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
		end
	
	
		part = function(formfactor, parent, reflectance, transparency, brickcolor, name, size)
			local fp = it("Part")
			fp.formFactor = formfactor
			fp.Parent = parent
			fp.Reflectance = reflectance
			fp.Transparency = transparency
			fp.CanCollide = false
			fp.Locked = true
			fp.BrickColor = brickcolor
			fp.Name = name
			fp.Size = size
			fp.Position = Torso.Position
			NoOutline(fp)
			if fp.BrickColor == BrickColor.new("Dark indigo") then
				fp.Material = "Neon"
			else
				if fp.BrickColor == BrickColor.new("Really black") then
					fp.BrickColor = BrickColor.new("Really black")
					fp.Material = "Metal"
				else
					fp.Material = "Neon"
				end
			end
			fp:BreakJoints()
			return fp
		end
	
		mesh = function(Mesh, part, meshtype, meshid, offset, scale)
			local mesh = it(Mesh)
			mesh.Parent = part
			if Mesh == "SpecialMesh" then
				mesh.MeshType = meshtype
				mesh.MeshId = meshid
			end
			mesh.Offset = offset
			mesh.Scale = scale
			return mesh
		end
	
		weld = function(parent, part0, part1, c0)
			local weld = it("Weld")
			weld.Parent = parent
			weld.Part0 = part0
			weld.Part1 = part1
			weld.C0 = c0
			return weld
		end
	
		F1 = Instance.new("Folder", Character)
		F1.Name = "Effects Folder"
		F2 = Instance.new("Folder", F1)
		F2.Name = "Effects"
		Triangle = function(a, b, c)
		end
	
		MagicBlock = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
			prt.Anchored = true
			prt.CanCollide = false
			prt.CFrame = cframe
			prt.Name = "prt"
			msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 5)
			table.insert(Effects, {prt, "Block1", delay, x3, y3, z3})
		end
	
	
	
		MagicCircle = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
			prt.Anchored = true
			prt.CanCollide = false
			prt.CFrame = cframe
			prt.Name = "prt"
			local msh = mesh("SpecialMesh", prt, "Sphere", "", vt(0, 0, 0), vt(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 5)
			table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3})
		end
	
		MagicWave = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = mesh("SpecialMesh", prt, "FileMesh", "http://www.roblox.com/asset/?id=20329976", vt(0, 0, 0), vt(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 5)
			table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3})
		end
	
		MagicCylinder = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt(0.2, 0.2, 0.2))
			prt.Anchored = true
			prt.CFrame = cframe
			msh = mesh("SpecialMesh", prt, "Head", "", vt(0, 0, 0), vt(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 5)
			Effects[#Effects + 1] = {prt, "Cylinder", delay, x3, y3, z3}
		end
	
		MagicCylinder2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt(0.2, 0.2, 0.2))
			prt.Anchored = true
			prt.CFrame = cframe
			msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 5)
			Effects[#Effects + 1] = {prt, "Cylinder", delay, x3, y3, z3}
		end
	
		MagicBlood = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = mesh("SpecialMesh", prt, "Sphere", "", vt(0, 0, 0), vt(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 5)
			table.insert(Effects, {prt, "Blood", delay, x3, y3, z3})
		end
	
		ElecEffect = function(cff, x, y, z)
			local prt = part(3, F2, 0, 0, BrickColor.new("Dark indigo"), "Part", vt(1, 1, 1))
			prt.Anchored = true
			prt.CFrame = cff * cf(math.random(-x, x), math.random(-y, y), math.random(-z, z))
			prt.CFrame = cf(prt.Position)
			game:GetService("Debris"):AddItem(prt, 2)
			xval = math.random() / 2
			yval = math.random() / 2
			zval = math.random() / 2
			msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(xval, yval, zval))
			Effects[#Effects + 1] = {prt, "Elec", 0.1, x, y, z, xval, yval, zval}
		end
	
		function FindNearestTorso(Position, Distance, SinglePlayer)
			if SinglePlayer then
				return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
			end
			local List = {}
			for i, v in pairs(workspace:GetChildren()) do
				if v:IsA("Model") then
					if v:findFirstChild("Torso") then
						if v ~= Character then
							if (v.Torso.Position - Position).magnitude <= Distance then
								table.insert(List, v)
							end 
						end 
					end 
				end 
			end
			return List
		end
	
	
		function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part"){
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material,
			}
			RemoveOutlines(Part)
			return Part
		end
	
		function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	
	
	
		function BlockEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
			local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			if Type == 1 or Type == nil then
				table.insert(Effects, {
					prt,
					"Block1",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			elseif Type == 2 then
				table.insert(Effects, {
					prt,
					"Block2",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		end
	
		function SphereEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	
		function RingEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay,material)
			local prt=CreatePart(workspace,material,0,0,brickcolor,"Effect",vt(.5,.5,.5))--part(3,workspace,"SmoothPlastic",0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
			prt.Anchored=true
			prt.CFrame=cframe
			msh=CreateMesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=3270017",vt(0,0,0),vt(x1,y1,z1))
			game:GetService("Debris"):AddItem(prt,2)
			coroutine.resume(coroutine.create(function(Part,Mesh,num) 
				for i=0,1,delay do
					swait()
					Part.Transparency=i
					Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
				end
				Part.Parent=nil
			end),prt,msh,(math.random(0,1)+math.random())/5)
		end
	
		function CylinderEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CreatePart(workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	
		function WaveEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	
		function SpecialEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://24388358", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	
	
		function MoonEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://259403370", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	
		function HeadEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CreateMesh("SpecialMesh", prt, "Head", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	
		function BreakEffect(brickcolor, cframe, x1, y1, z1)
			local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
			prt.Anchored = true
			prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
			local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			local num = math.random(10, 50) / 1000
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Shatter",
				num,
				prt.CFrame,
				math.random() - math.random(),
				0,
				math.random(50, 100) / 100
			})
		end
	
		local lerp = function(a, b, t)
			return a * (1 - t) + b * t
		end
	
		function clerp(a,b,t)
			local qa = {QuaternionFromCFrame(a)}
			local qb = {QuaternionFromCFrame(b)}
			local ax, ay, az = a.x, a.y, a.z
			local bx, by, bz = b.x, b.y, b.z
			local _t = 1-t
			return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t))
		end
	
		function QuaternionFromCFrame(cf)
			local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
			local trace = m00 + m11 + m22
			if trace > 0 then
				local s = math.sqrt(1 + trace)
				local recip = 0.5/s
				return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5
			else
				local i = 0
				if m11 > m00 then
					i = 1
				end
				if m22 > (i == 0 and m00 or m11) then
					i = 2
				end
				if i == 0 then
					local s = math.sqrt(m00-m11-m22+1)
					local recip = 0.5/s
					return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip
				elseif i == 1 then
					local s = math.sqrt(m11-m22-m00+1)
					local recip = 0.5/s
					return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip
				elseif i == 2 then
					local s = math.sqrt(m22-m00-m11+1)
					local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip
				end
			end
		end
	
	
		function QuaternionToCFrame(px, py, pz, x, y, z, w)
			local xs, ys, zs = x + x, y + y, z + z
			local wx, wy, wz = w*xs, w*ys, w*zs
			local xx = x*xs
			local xy = x*ys
			local xz = x*zs
			local yy = y*ys
			local yz = y*zs
			local zz = z*zs
			return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy))
		end
		function QuaternionSlerp(a, b, t)
			local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4]
			local startInterp, finishInterp;
			if cosTheta >= 0.0001 then
				if (1 - cosTheta) > 0.0001 then
					local theta = math.acos(cosTheta)
					local invSinTheta = 1/math.sin(theta)
					startInterp = math.sin((1-t)*theta)*invSinTheta
					finishInterp = math.sin(t*theta)*invSinTheta  
				else
					startInterp = 1-t
					finishInterp = t
				end
			else
				if (1+cosTheta) > 0.0001 then
					local theta = math.acos(-cosTheta)
					local invSinTheta = 1/math.sin(theta)
					startInterp = math.sin((t-1)*theta)*invSinTheta
					finishInterp = math.sin(t*theta)*invSinTheta
				else
					startInterp = t-1
					finishInterp = t
				end
			end
			return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp
		end
	
		function weld5(part0, part1, c0, c1)
			weeld=Instance.new("Weld", part0)
			weeld.Part0=part0
			weeld.Part1=part1
			weeld.C0=c0
			weeld.C1=c1
			return weeld
		end
	
		--Example: Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
	
		function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
			return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
		end
	
	
	
	
	
	
		Character.Humanoid.MaxHealth = 120
		Character.Humanoid.Health = 120
	
		local f = 0
		local b = Instance.new("BlurEffect",cam)
		local    c = Instance.new('PointLight', Torso)
		c.Range = 16
		c.Color = Color3.new(0, 1,1)
		c.Brightness = 1.5
		game:GetService("RunService"):BindToRenderStep("W0tT", 0, function()
	
			b.Size = b.Size - 4
			if boost == true then
				c.Enabled = true
				cam.FieldOfView = lerp(cam.FieldOfView, 110, 0.5)
				-- cam.FieldOfView = 110
				freefall = 0
				Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,3),0.25)
				SphereEffect(BrickColor.new("Cyan"),RightLeg.CFrame*CFrame.new(0,-1,0)*angles(math.random(-180,180),math.random(-180,180),math.random(-180,180)),1.4,12,1.4,2.8,26,2.8,0.07)
				SphereEffect(BrickColor.new("Cyan"),LeftLeg.CFrame*CFrame.new(0,-1,0)*angles(math.random(-180,180),math.random(-180,180),math.random(-180,180)),1.4,12,1.4,2.8,26,2.8,0.07)
				if hitfloor ~= nil and Anim ~= "runIdle" then
					SpecialEffect(BrickColor.new("Cyan"),RootPart.CFrame*CFrame.new(0,-3.4,.78) ,2,2,2, 1.5,1.5,1.5,.09)
				end
			end
			if boost == false then
				cam.FieldOfView = lerp(cam.FieldOfView, 70, 0.076)
				--cam.FieldOfView = 70
				c.Enabled = false
			end
		end)
	
	
	
		mouse.KeyDown:connect(function(key)
			if string.byte(key) == 48 then
				b.Size = 40
				Swing = 2
				freefall = 0
	
				coroutine.resume(coroutine.create(function()
					for i = 0,1,0.1 do
						swait()
						Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
					end
				end))
				Humanoid.WalkSpeed = 180
				RootPart.Velocity = RootPart.CFrame.lookVector*150
				RingEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,-9.2) , 1, 1, 1, 8, 8, 8, 0.14,"Neon") 
				boost = true
				boostsound:Play()
			end
		end)
	
		mouse.KeyUp:connect(function(key)
			if string.byte(key) == 48 then
				Swing = 1
				Humanoid.WalkSpeed = 64
				boost = false
				boostsound:Stop()
	
			end
		end)
	
	
	
	
		mouse.KeyDown:connect(function(key)
			if string.byte(key) == 50 then
				b.Size = 40
				freefall = 0
				Swing = 2
	
				coroutine.resume(coroutine.create(function()
					for i = 0,1,0.1 do
						swait()
						Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(math.random(-0.35*2.8,0.35*2.8),math.random(-0.35*2.8,0.35*2.8),math.random(-0.35*2.8,0.35*2.8)),0.48)
					end
				end))
	
				Humanoid.WalkSpeed = 320
				RootPart.Velocity = RootPart.CFrame.lookVector*550
				RingEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,-9.2) , 1, 1, 1, 18, 18, 18, 0.14,"Neon") 
				RingEffect(BrickColor.new("White"), RootPart.CFrame*CFrame.new(0,0,-11.2) , 1, 1, 1, 18, 18, 18, 0.14,"Neon") 
				RingEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,-13.2) , 1, 1, 1, 18, 18, 18, 0.14,"Neon") 
				boost = true
				boostsound:Play()
			end
		end)
	
		mouse.KeyUp:connect(function(key)
			if string.byte(key) == 50 then
				Swing = 1
				Humanoid.WalkSpeed = 64
				boost = false
				boostsound:Stop()
	
			end
		end)
	
	
		local lastwall = nil
		local jumped = false
	
	
	
	
	
	
		local vwall = false
	
		mouse.KeyDown:connect(function(key)
			if key == 'b' and hitfloor == nil and attack == false then
				vrun()
			end
		end)
	
	
		function vrun()
			local ray = Ray.new(
				RootPart.CFrame.p, RootPart.CFrame.lookVector *2.5
			)
			local hit, position, normal = workspace:FindPartOnRay(ray, character)
	
			if hit then
				if hit.Parent.Parent ~= Character and hit.Parent ~= Character and hit.Name ~= "prt" and hit.CanCollide == true then
					vwall = true
					local NV = Vector3.new(0,0,0)
					local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude + 10
					local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
					local GravPoint = RootPart.Velocity.y
					local velo = Instance.new("BodyVelocity",Torso)
					velo.MaxForce = Vector3.new(400000,400000,400000)
	
					attack = true
					while vwall == true and ray and hit do
						swait()
						change = 0.84+ Humanoid.WalkSpeed/132
						if Humanoid.WalkSpeed > 40 and Humanoid.WalkSpeed < 70 then
							velo.Velocity =  Vector3.new(0,40,0)
						end
						if Humanoid.WalkSpeed > 70 and Humanoid.WalkSpeed < 200 then
							velo.Velocity =  Vector3.new(0,80,0)
						end
						if Humanoid.WalkSpeed > 200 then
							velo.Velocity =  Vector3.new(0,130,0)
						end
						ray = Ray.new(
							RootPart.CFrame.p, RootPart.CFrame.lookVector *2.5
						)
						hit, position, normal = workspace:FindPartOnRay(ray, character)
						Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/2), .6) * angles(math.rad(96), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .1)
						Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+20*math.sin(sine/2)),math.rad(0),math.rad(0+5*math.sin(sine/4)) + RootPart.RotVelocity.Y / 13),.1)
						RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.1) * angles(math.rad(-90-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(15+2*math.sin(sine/4))- RootPart.RotVelocity.Y / 34),.15)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.1)*angles(math.rad(-90-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(-15+2*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34),.15)
						LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.28*math.cos(sine/4), 0-0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0+104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.3+ Humanoid.WalkSpeed/272)
						RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.28*math.cos(sine/4),0+0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0-104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.3+ Humanoid.WalkSpeed/272)
					end
					velo:Destroy()
					wait(0.07)
	
					if vwall == false then
	
						RootPart.Velocity = -RootPart.CFrame.lookVector*68 + Vector3.new(0,86,0)
	
	--[[]
			for i = 0,5,0.2 do
	rs:wait()
	Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -0.79, 0) * CFrame.Angles(math.rad(0+100*i), math.rad(0), math.rad(0)), 0.2)
	Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(0),math.rad(0)),.2)
	RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(180), math.rad(-60), math.rad(40)),.2)
	LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(180), math.rad(60), math.rad(-40)),.2)
	LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
	RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
	end
	]]
	
	
						for i = 0,4,0.1 do
							swait()
							Humanoid.CameraOffset = Vector3.new(0,0,0)
							Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0+260*i), math.rad(0), math.rad(0)), 0.6)
							Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
							RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
							LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
							LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
							RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
						end
	
						attack = false
	
	
					end
	
	
					if vwall == true then
						RootPart.Velocity = RootPart.CFrame.lookVector*38 + Vector3.new(0,86,0)
	
	--[[]
			for i = 0,5,0.2 do
	rs:wait()
	Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -0.79, 0) * CFrame.Angles(math.rad(0+100*i), math.rad(0), math.rad(0)), 0.2)
	Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(0),math.rad(0)),.2)
	RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(180), math.rad(-60), math.rad(40)),.2)
	LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(180), math.rad(60), math.rad(-40)),.2)
	LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
	RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
	end
	]]
	
	
						for i = 0,4,0.15 do
							swait()
							Humanoid.CameraOffset = Vector3.new(0,0,0)
							Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0-260*i), math.rad(0), math.rad(0)), 0.6)
							Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
							RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
							LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
							LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
							RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
						end
	
						attack = false
	
					end
	
	
				end
			end
		end
	
	
	
	
		mouse.KeyUp:connect(function(key)
			if key == 'b' and vwall == true then
				vwall = false
			end
		end)
	
	
	
	
	
		function Ldash()
	
	
	
			evadecooldown = true
			attack = true
			k = math.random(1,2) 
			if k == 1 then
				so("http://www.roblox.com/asset/?id=807766310", Head, 2.5, 1)
			else
				so("http://www.roblox.com/asset/?id=807768137", Head, 2.5, 1)
			end
	
	
	
	
	
			--+173.8*i
			for i = 0,.7,0.1 do
				swait()
				Head.Velocity = Head.CFrame.rightVector * -135
				Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(32)), 0.2)
				Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(-9),math.rad(-14)),.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -0.2) * angles(math.rad(27), math.rad(0), math.rad(30)),.2)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(30), math.rad(0), math.rad(30)),.2)
				LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(12)), 0.2)
				RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(8)), 0.2)
			end
	
			attack = false
			wait(0.08)
			evadecooldown = false
	
	
		end
	
	
	
	
	
		function Rdash()
	
	
	
			evadecooldown = true
			attack = true
			k = math.random(1,2) 
			if k == 1 then
				so("http://www.roblox.com/asset/?id=807766310", Head, 2.5, 1)
			else
				so("http://www.roblox.com/asset/?id=807768137", Head, 2.5, 1)
			end
	
	
	
	
	
			--+173.8*i
			for i = 0,.7,0.1 do
				swait()
				Head.Velocity = Head.CFrame.rightVector * 135
				Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-32)), 0.2)
				Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(9),math.rad(14)),.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(30), math.rad(0), math.rad(-30)),.2)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0.2) * angles(math.rad(27), math.rad(0), math.rad(-30)),.2)
				LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-8)), 0.2)
				RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-12)), 0.2)
			end
	
			attack = false
			wait(0.08)
			evadecooldown = false
	
	
		end
		local sliding = false
	
	
		function Slide()
	
			local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude + 10
			spd = spd + 30
			local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
			local GravPoint = RootPart.Velocity.y
			if spd > 40 and hitfloor ~= nil then
				noleg = true
	
				attack = true
				k = math.random(1,2) 
				if k == 1 then
					so("http://www.roblox.com/asset/?id=807766310", Head, 2.5, 1)
				else
					so("http://www.roblox.com/asset/?id=807768137", Head, 2.5, 1)
				end
	
	
	
	
	
	
	
	
	
	
				local NV = Vector3.new(0,0,0)
				local bv = Instance.new("BodyVelocity", Torso)
				bv.maxForce = Vector3.new(1/0,1/0,1/0)
				bv.velocity = dir*spd
				local bg = Instance.new("BodyGyro", Torso)
				bg.maxTorque = Vector3.new(1/0,1/0,1/0)
				bg.cframe = CFrame.new(NV, dir) * CFrame.Angles(math.pi/2.2,0.24,0)
				Head.Running.SoundId = "rbxassetid://1295468446"
				Head.Running.TimePosition = 0
	
				Humanoid.PlatformStand = true
				while spd > 2 and hitfloor ~= nil and sliding == true do
					swait()
					spd = spd - 0.95
					bv.velocity = dir*spd + Vector3.new(0,0,0)
					bg.cframe = CFrame.new(NV, dir) * CFrame.Angles(math.pi/2.2,0.24,0)
					Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -2.3, 0) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(12)), 0.2)
					Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(34),math.rad(0),math.rad(12)),.2)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(110), math.rad(0), math.rad(70)),.2)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0.2) * angles(math.rad(0), math.rad(0), math.rad(-60)),.2)
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -0.56, -0.2) * CFrame.Angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
				end
				bv:Destroy()
				bg:Destroy()
				Head.Running.SoundId = "rbxassetid://758199523"
				Head.Running.TimePosition = 0
				Humanoid.PlatformStand = false
				attack = false
				sliding = false
				wait(0.05)
				evadecooldown = false
	
	
			end
		end
	
		function land()
			attack = true
			RootPart.Velocity = Vector3.new(0,0,0)
			WaveEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,-1,0) , 1, 1, 1, 3, 0.8, 3, 0.06) 
			so("http://www.roblox.com/asset/?id=1295424585", Torso, 3.5, 1)
	
			coroutine.resume(coroutine.create(function()
				for i = 0,1,0.1 do
					swait()
					Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(math.random(-0.55*2.8,0.55*2.8),math.random(-0.55*2.8,0.55*2.8),math.random(-0.55*2.8,0.55*2.8)),0.44)
					Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -2, 0) * CFrame.Angles(math.rad(-16), math.rad(0), math.rad(0)), 0.5)
					Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(7),math.rad(0),math.rad(0)),.5)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(87)),.5)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0) * angles(math.rad(0), math.rad(0), math.rad(-87)),.5)
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, 0, -0.5) * CFrame.Angles(math.rad(16), math.rad(0), math.rad(0)), 0.5)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1.14, 0.2) * CFrame.Angles(math.rad(-17), math.rad(0), math.rad(0)), 0.5)
	
				end
				attack = false
	
	
			end))
	
	
	
		end
	
	
	
	
		function stomp()
			attack = true
			stompsound:Play()
	
			while hitfloor == nil do 
				swait()
				b.Size = 12
				WaveEffect(BrickColor.new("Cyan"), LeftLeg.CFrame*CFrame.new(0,-2.4,0) , 1, 1, 1, 0.8, 0.8, 0.8, 0.14) 
				RootPart.Velocity = Vector3.new(0,RootPart.Velocity.y/1.6,0) +Vector3.new(0,-150,0)
				Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
				Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.2) * CFrame.Angles(math.rad(0+4*math.sin(sine/1.3)), math.rad(0), math.rad(0)),0.07)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(140+12*math.cos(sine/1.3))), 0.07)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(-140+12*math.cos(sine/1.3))), 0.07)
				Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(60+7*math.sin(sine/1.3)),math.rad(0),math.rad(0)),0.07)
				LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.17*math.cos(sine/1.3), -0.13) * CFrame.Angles(math.rad(0+4*math.cos(sine/1.3)), math.rad(3), math.rad(0)), 0.1)
				RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, .27+0.17*math.cos(sine/1.3), -0.56) * CFrame.Angles(math.rad(-12+4*math.cos(sine/1.3)), math.rad(0), math.rad(0)), 0.1)
	
			end
			stompsound:Stop()
			land()
	
	
		end
	
	
		function changemusic()
			musicnum = musicnum + 1
			music.TimePosition = 0
			local osix = false
			local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude
			if musicnum > 14 then
				musicnum = 1
			end
			if musicnum == 1 then
				music.SoundId = "rbxassetid://179029173"
			end
			if musicnum == 2 then
				music.SoundId = "rbxassetid://146443855"
			end
			if musicnum == 3 then
				music.SoundId = "rbxassetid://1342408291" 
			end
			if musicnum == 4 then
				music.SoundId = "rbxassetid://201219416"  
			end
			if musicnum == 5 then
				music.SoundId = "rbxassetid://1390472571" 
			end
			if musicnum == 6 then
				osix = true
				music.SoundId = "rbxassetid://249974783" 
			end
			if musicnum == 7 then
				music.SoundId = "rbxassetid://1851880603"
			end
			if musicnum == 8 then
				music.SoundId = "rbxassetid://412034984"
			end
			if musicnum == 9 then
				music.SoundId = "rbxassetid://536915629"
			end
			if musicnum == 10 then
				music.SoundId = "rbxassetid://1200005861"
			end
			if musicnum == 11 then
				music.SoundId = "rbxassetid://1055930631"
			end
			if musicnum == 12 then
				music.SoundId = "rbxassetid://300269553"
			end
			if musicnum == 13 then
				music.SoundId = "rbxassetid://199897052"
			end
			if musicnum == 14 then
				music.SoundId = "rbxassetid://638115895"  
			end
	
			if spd < 14 then
				Humanoid.Jump = true
	
				if osix == false then
					so("rbxassetid://537371462",PlayerGui,2,1)
				end
	
	
				RootPart.Velocity = Vector3.new(0,102,0)
				attack = true
				wait(0.08)
				for i = 0,7,0.1 do
					swait()
					RootPart.Velocity = Vector3.new(0,2,0)
					Humanoid.CameraOffset = Vector3.new(0,0,0)
					Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0-260*i), math.rad(0), math.rad(0)), 0.6)
					Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
					RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
	
				end
				b.Size = 40
				MoonEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,0) , 1, 1, 1, 8, 8, 8, 0.06) 
	
				if osix == true then
					osix = false
					so("rbxassetid://156821036",PlayerGui,2,1)
				end
	
				Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -3, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 1)
				for i = 0,5,0.1 do
					swait()
					RootPart.Velocity = Vector3.new(0,3.5,0)
					Humanoid.CameraOffset = Vector3.new(0,0,0)
					Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1+0.1*i, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.21)
					Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(22-2*i),math.rad(0),math.rad(0)),.21)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.09*i, 0) * angles(math.rad(20-6*i), math.rad(0), math.rad(90+13*i)), 0.21)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.0-0.12*i, 0.5, -0.4+0.05*i) * angles(math.rad(20+13*i), math.rad(0), math.rad(20-13*i)), 0.21)
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(-22-4*i)), 0.21)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(22+4*i)), 0.21)
				end
				attack = false
			end
		end
	
	
		mouse.KeyDown:connect(function(key)
			if key == 'q' and attack == false and evadecooldown == false then
				Ldash()
			end
		end)
	
	
	
		mouse.KeyDown:connect(function(key)
			if key == 'e' and attack == false and evadecooldown == false then
				Rdash()
			end
		end)
	
		mouse.KeyDown:connect(function(key)
			if key == 'c' and attack == false and evadecooldown == false and hitfloor ~= nil then
				sliding = true
				Slide()
			end
		end)
	
		mouse.KeyDown:connect(function(key)
			if key == 'c' and attack == false and hitfloor == nil then
				stomp()
			end
		end)
	
	
		local walljump = false
	
	
		function walljumpp()
			local ray = Ray.new(
				Torso.CFrame.p, RootPart.CFrame.lookVector *5
			)
			local hit, position, normal = workspace:FindPartOnRay(ray, character)
	
			if hit then
				if  hit.Parent.Parent ~= Character and hit.Parent ~= Character then
					local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
					GravPoint = 0
					freefall = 0
					walljump = true 
					Humanoid.AutoRotate = false
					local velo = Instance.new("BodyVelocity",Torso)
					velo.MaxForce = Vector3.new(400000,400000,400000)
					--game.Debris:AddItem(velo,0.1)
					attack = true
					while hitfloor == nil and walljump == true and ray and hit  do
						swait()
						freefall = 0
						GravPoint = GravPoint - 0.36
						ray = Ray.new(
							RootPart.CFrame.p, RootPart.CFrame.lookVector *2.5
						)
						hit, position, normal = workspace:FindPartOnRay(ray, character)
						velo.Velocity = vt(0,GravPoint,0)
						Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.9) * CFrame.Angles(math.rad(5), math.rad(90), math.rad(8)), 0.2)
						Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(7),math.rad(0),math.rad(86)),.2)
						RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(120)),.2)
						LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-60)),.2)
						LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-6), math.rad(14), math.rad(-12)), 0.2)
						RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(23)), 0.2)
					end
					if walljump == false then
						k = math.random(1,3) 
						if k == 1 then
							so("http://www.roblox.com/asset/?id=800121776", Head, 2.5, 1)
						else if k == 2 then
								so("http://www.roblox.com/asset/?id=804889329", Head, 2.5, 1)
							else if k == 3 then
									so("http://www.roblox.com/asset/?id=804907617", Head, 2.5, 1)
								end
							end
						end
	
						velo:Destroy()
						attack = false
						coroutine.resume(coroutine.create(function()
							for i = 0,1,0.1 do
								swait()
								Humanoid.CameraOffset = Vector3.new(0,0,0)
								Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0+260*i), math.rad(0), math.rad(0)), 0.6)
								Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
								RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
								LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
								LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
								RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
							end
						end))
	
						Humanoid.AutoRotate = true
						RootPart.Velocity = RootPart.CFrame.lookVector * -137 + Vector3.new(0,136,0)
						wait(0.07)
						RootPart.CFrame = CFrame.new(RootPart.CFrame.p,-RootPart.CFrame.lookVector)
					end
					if walljump == true then
						attack = false
						walljump = false
						Humanoid.AutoRotate = true
						velo:Destroy()
					end
				end
			end
		end
	
	
		local homed = nil
		function home()
			if walljump ~= true then
				for i, v in pairs(FindNearestTorso(Torso.CFrame.p, 80)) do
					if v:FindFirstChild('Head') then
						Grabbed = true
						homed = v
					end
				end
	
				if homed ~= nil and homed:FindFirstChildOfClass("Humanoid").Health > 1 and walljump == false then
					so("http://www.roblox.com/asset/?id=162460823", Head, 1, .8)
					local SBall = Instance.new("Part",Character)
					SBall.Name = "Homing Ball"
					SBall.CanCollide = false
					SBall.Anchored = false
					SBall.Transparency = 0.64
					SBall.CFrame = CFrame.new(RootPart.CFrame.p)
					SBall.BrickColor = BrickColor.new("Toothpaste")
					SBall.Size = Vector3.new(1,1,1)
					SBall.Material = "Neon"
					SBallweld = Instance.new("Weld")
					SBallweld.Parent = SBall
					SBallweld.Part0 = RootPart
					SBallweld.Part1 = SBall
					SBallweld.C1 = CFrame.new(0, 1, 0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
					SBallweld.Part0 = RootPart
					local SBallmesh = Instance.new("SpecialMesh",SBall)
					SBallmesh.MeshType = "Sphere"
					SBallmesh.Scale = Vector3.new(6,6,6)
					trail = Instance.new("Trail", Character)
					a2 = Instance.new("Attachment", Torso) a2.Position = Vector3.new(0,2,0)
					a3 = Instance.new("Attachment", Torso)a3.Position = Vector3.new(0,-2.5,0)
					trail.Texture = "rbxassetid://0"
					trail.Attachment0 = a2
					trail.Attachment1 = a3
					trail.Lifetime  =  0.353
					trail.MinLength = 0.03
					trail.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,1)})
					trail.Color = ColorSequence.new(Color3.new(0,1,1), Color3.new(0, 0,0))
					trail.LightEmission = 4.8
					trail.TextureLength = 0.034
					trail.Enabled = true
					attack = true
					local position = Instance.new("BodyPosition",Torso)
					position.P = 68350
					position.maxForce = Vector3.new(math.huge,math.huge,math.huge)
	
					while homed ~= nil and (homed.Torso.Position-RootPart.Position).magnitude > 8 do
						swait()
						SBall.CFrame = CFrame.new(RootPart.CFrame.p)
						Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0+420*math.abs(sine/3.2)), math.rad(0), math.rad(0)), 0.6)
						Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
						RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
						LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
						LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
						RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
						position.Position = homed.Torso.Position + Vector3.new(0,2,0) 
					end
					local bodvol=Instance.new("BodyVelocity")
					bodvol.velocity= RootPart.CFrame.lookVector*240 + Vector3.new(0,30,0)
					bodvol.P= 35200
					bodvol.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)
					bodvol.Parent=homed.Head
					game:GetService("Debris"):AddItem(bodvol, 0.2)
					homed:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(10,30))
	
					position:Destroy()
					trail.Enabled = false
					SBall:Destroy()
					RootPart.Velocity = Vector3.new(0,93.5,0)
					coroutine.resume(coroutine.create(function()
						for i = 0,5,0.26 do
							swait()
							Humanoid.CameraOffset = Vector3.new(0,0,0)
							Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1+0.1*i, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.21)
							Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(22-2*i),math.rad(0),math.rad(0)),.21)
							RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.09*i, 0) * angles(math.rad(20-6*i), math.rad(0), math.rad(90+13*i)), 0.21)
							LW.C0 = clerp(LW.C0, CFrame.new(-1.0-0.12*i, 0.5, -0.4+0.05*i) * angles(math.rad(20+13*i), math.rad(0), math.rad(20-13*i)), 0.21)
							LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(-22-4*i)), 0.21)
							RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(22+4*i)), 0.21)
						end
						homed = nil
						attack = false
					end))
	
				end
	
			end
	
	
		end
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		mouse.KeyDown:connect(function(key)
			wait(0.16)
			if string.byte(key) == 32 and hitfloor == nil and attack == false and walljump == false and Humanoid.Jump == true then
				walljumpp()
			end
			if string.byte(key) == 32 and hitfloor == nil and attack == false and walljump == false and Humanoid.Jump == true then
				home()
			end
	
			if string.byte(key) == 32 and hitfloor == nil and attack == true and walljump == true then
				walljump = false
			end
		end)
	
	
	
	
		mouse.KeyDown:connect(function(key)
			if key == 'm' and attack == false then
				changemusic()
			end
		end)
	
	
	
	
	
	
		mouse.KeyUp:connect(function(key)
			wait(0.05)
			if key == 'c' and sliding == true then
				sliding = false
			end
		end)
		local look = 0
	
	
	
		while true do
			swait()
			sine = sine + change
			--speed = speed + music.PlaybackLoudness/90
			local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude
			local velderp=RootPart.Velocity.y
			hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
	
			local TiltVelocity = CFrame.new(RootPart.CFrame:vectorToObjectSpace(RootPart.Velocity))
	
			local rlegray = Ray.new(RightLeg.Position+Vector3.new(0,0.54,0),Vector3.new(0, -1.75, 0))
			local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, Character)
	
			local llegray = Ray.new(LeftLeg.Position+Vector3.new(0,0.54,0),Vector3.new(0, -1.75, 0))
			local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, Character)
	
			local waterthing = Ray.new(RootPart.CFrame.p,Vector3.new(0,-1,0))
			local start, position = workspace:FindPartOnRay(waterthing, character)
	
			if start ~= nil and start.Material == "Water" then
	
				RootPart.Velocity = RootPart.Velocity + Vector3.new(0,6,0)
	
			end
	
			Head.Running.Pitch = 0.76 + Humanoid.WalkSpeed/124
			if torvel<1  and Swing == 2 then
				boost = false
			elseif torvel>1   and Swing == 2 then
				boost = true
				freefall = 0
			end
			if hitfloor ~= nil and freefall < 150 then
				freefall = 0
			end
			if freefall > 150 and hitfloor ~= nil then
				land()
				freefall = 0
			end
	
	
	
	
	
	
	
			if RootPart.Velocity.y > 1 and hitfloor==nil then
				Anim="Jump"
	
	
	
	
	
				if attack==false then
					change = 1
					look = 0
					Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
					Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(4), math.rad(0), math.rad(0)), 0.07)
					Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10+2.05*math.cos(sine/5)),math.rad(0),math.rad(0)),0.07)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-20+2.05*math.cos(sine/5)), math.rad(-10), math.rad(50-2.05*math.cos(sine/5))), 0.07)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20+2.05*math.cos(sine/5)), math.rad(-10), math.rad(-50+2.05*math.cos(sine/5))), 0.07)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, -0.6) * CFrame.Angles(math.rad(-25+3.05*math.cos(sine/5)), math.rad(-3), math.rad(0)), 0.1)
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.47, -0.7) * CFrame.Angles(math.rad(-12+3.05*math.cos(sine/5)), math.rad(0), math.rad(0)), 0.1)
				end
	
			elseif RootPart.Velocity.y < -1 and freefall <150 and hitfloor==nil then
				Anim="Fall"
				change = 1
				freefall = freefall +0.77
	
	
				if attack==false then
					Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
					Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.2) * CFrame.Angles(math.rad(7+4*math.sin(sine/1.3)), math.rad(0), math.rad(0)),0.07)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(140+12*math.cos(sine/1.3))), 0.07)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(-140+12*math.cos(sine/1.3))), 0.07)
					Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(40+7*math.sin(sine/1.3)),math.rad(0),math.rad(0)),0.07)
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.17*math.cos(sine/1.3), -0.13) * CFrame.Angles(math.rad(18+7*math.cos(sine/1.3)), math.rad(3), math.rad(0)), 0.1)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.37+0.17*math.cos(sine/1.3), -0.2) * CFrame.Angles(math.rad(32+7*math.cos(sine/1.3)), math.rad(0), math.rad(0)), 0.1)
				end
	
	
	
			elseif RootPart.Velocity.y < -1 and freefall > 150 and hitfloor==nil then
				Anim="FreeFall"
				change = 1
	
	
				if attack==false then
					Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
					Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.2) * CFrame.Angles(math.rad(-90+3*math.sin(sine/1.3)), math.rad(0), math.rad(0)),0.07)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(14+12*math.cos(sine/1.3)), math.rad(0), math.rad(110)), 0.07)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(14+12*math.cos(sine/1.3)), math.rad(0), math.rad(-110)), 0.07)
					Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-12+7*math.sin(sine/1.3)),math.rad(0),math.rad(0)),0.07)
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.17*math.cos(sine/1.3),0.2) * CFrame.Angles(math.rad(-12+4*math.cos(sine/1.3)), math.rad(3), math.rad(-46)), 0.1)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1+0.17*math.cos(sine/1.3), 0.2) * CFrame.Angles(math.rad(-12+4*math.cos(sine/1.3)), math.rad(0), math.rad(46)), 0.1)
				end
	
			elseif torvel<1 and hitfloor~=nil then
				Anim="Idle"
				change = 1
				if attack==false and equip == false then
	
					Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
					Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.04*math.cos(sine/40), -0) * CFrame.Angles(math.rad(0-0.81*math.cos(sine/40)), math.rad(-40), math.rad(0)), 0.1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0+2.6*math.sin(sine/40)),math.rad(0),math.rad(40)),0.1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.55+0.04*math.sin(sine/40), 0-0.04*math.cos(sine/40)) * angles(math.rad(-2+1.3*math.cos(sine/40)), math.rad(0+4*math.sin(sine/40)), math.rad(6.3+2.2*math.cos(sine/40))),0.1)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.55+0.04*math.sin(sine/40), 0-0.04*math.cos(sine/40)) * angles(math.rad(2+1.3*math.cos(sine/40)), math.rad(0-4*math.sin(sine/40)), math.rad(-6.3-2.2*math.cos(sine/40))),0.1)
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, llegendPoint.Y-LeftLeg.Position.Y+0.04*math.cos(sine/40), 0) * CFrame.Angles(math.rad(0+0.81*math.cos(sine/40)), math.rad(18+0.81*math.cos(sine/40)), math.rad(-2-0.81*math.cos(sine/40))),0.1)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.57, rlegendPoint.Y-RightLeg.Position.Y+0.04*math.cos(sine/40), 0)  * CFrame.Angles(math.rad(0+0.81*math.cos(sine/40)), math.rad(-2+0.81*math.cos(sine/40)), math.rad(3-0.81*math.cos(sine/40))),0.1)
				end
	
	
	
			elseif torvel>1.5 and torvel<70 and hitfloor~=nil then
				Anim="Walk"
				change = 0.84+ Character.Humanoid.WalkSpeed/132
				look = 0
				if attack==false and equip == false then
					Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.02)
					Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/2), -.8) * angles(math.rad(-26), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+20*math.sin(sine/2)),math.rad(0),math.rad(0+5*math.sin(sine/4)) + RootPart.RotVelocity.Y / 13),.1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.1) * angles(math.rad(-60-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(15+2*math.sin(sine/4))- RootPart.RotVelocity.Y / 34),.15)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.1)*angles(math.rad(-60-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(-15+2*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34),.15)
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.28*math.cos(sine/4), 0-0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0+104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.3)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.28*math.cos(sine/4),0+0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0-104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.3)
				end
	
	
			elseif torvel>=70 and torvel<200 and hitfloor~=nil then
				Anim="Run"
				change = 0.84+ Character.Humanoid.WalkSpeed/142
				if attack==false and equip == false then
					Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.02)
					Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/1.5), -.8) * angles(math.rad(-37), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .1)
					Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+25*math.sin(sine/1.5)),math.rad(0),math.rad(0+5*math.sin(sine/3)) + RootPart.RotVelocity.Y / 13),.1)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.3) * angles(math.rad(-72-8*math.sin(sine/1.5))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(1+0*math.cos(sine/3))- RootPart.RotVelocity.Y / 34),.25)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.3)*angles(math.rad(-72-8*math.sin(sine/1.5))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(-1+0*math.cos(sine/3))+ RootPart.RotVelocity.Y / -34),.25)
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.32*math.cos(sine/3), 0-0.42*math.cos(sine/3)) * CFrame.Angles(math.rad(0+134*math.sin(sine/3)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.44)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.32*math.cos(sine/3),0+0.42*math.cos(sine/3)) * CFrame.Angles(math.rad(0-134*math.sin(sine/3)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.44)
				end
	
			--[[
			if attack==false then
			LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1-0.4*math.cos(sine/5.5)/2, 0 *math.sin(sine/6.6)/2) * CFrame.Angles(math.rad(0) + -math.sin(sine/5.5)/1.2, math.rad(0), 0), .8)
			RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1+0.4*math.cos(sine/5.5)/2,0 *-math.sin(sine/6.6)/2) * CFrame.Angles(math.rad(0) + math.sin(sine/5.5)/1.2, math.rad(0), 0), .8)
			end
			]]
				if attack==true and noleg == false then
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1-0.24*math.cos(sine/5), 0.+0.24*math.cos(sine/5)) * CFrame.Angles(math.rad(0-74*math.sin(sine/5)), math.rad(0), math.rad(0)), 0.3)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1+0.24*math.cos(sine/5),0.-0.24*math.cos(sine/5)) * CFrame.Angles(math.rad(0+74*math.sin(sine/5)), math.rad(0), math.rad(0)), 0.3)
				end
	
	
	
			elseif torvel>=200 and hitfloor~=nil then
				Anim="MachRun"
				change = 0.84+ Character.Humanoid.WalkSpeed/182
				if attack==false and equip == false then
					Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.02)
					Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/1), -3.8) * angles(math.rad(-44), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .2)
					Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+25*math.sin(sine/1)),math.rad(0),math.rad(0+5*math.sin(sine/2)) + RootPart.RotVelocity.Y / 13),.2)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.5) * angles(math.rad(-78-12*math.sin(sine/1))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(-24+0*math.cos(sine/2))- RootPart.RotVelocity.Y / 34),.35)
					LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.5)*angles(math.rad(-78-12*math.sin(sine/1))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(24+0*math.cos(sine/2))+ RootPart.RotVelocity.Y / -34),.35)
					LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.42*math.cos(sine/2), 0-0.62*math.cos(sine/2)) * CFrame.Angles(math.rad(0+134*math.sin(sine/2)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.52)
					RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.42*math.cos(sine/2),0+0.62*math.cos(sine/2)) * CFrame.Angles(math.rad(0-134*math.sin(sine/2)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.52)
				end
	
	
	
			end
	
	
	
	
	
	
	
	
	
			if 0 < #Effects then
				for e = 1, #Effects do
					if Effects[e] ~= nil then
						local Thing = Effects[e]
						if Thing ~= nil then
							local Part = Thing[1]
							local Mode = Thing[2]
							local Delay = Thing[3]
							local IncX = Thing[4]
							local IncY = Thing[5]
							local IncZ = Thing[6]
							if Thing[1].Transparency <= 1 then
								if Thing[2] == "Block1" then
									Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
									Mesh = Thing[1]:FindFirstChild("Mesh")
									if not Mesh then
										Mesh = Instance.new("BlockMesh")
									end
									Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Cylinder" then
									Mesh = Thing[1]:FindFirstChild("Mesh")
									if not Mesh then
										Mesh = Instance.new("BlockMesh")
									end
									Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Blood" then
									Mesh = Thing[1]:FindFirstChild("Mesh")
									if not Mesh then
										Mesh = Instance.new("BlockMesh")
									end
									Thing[1].CFrame = Thing[1].CFrame * cf(0, 0.5, 0)
									Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Elec" then
									Mesh = Thing[1]:FindFirstChild("Mesh")
									if not Mesh then
										Mesh = Instance.new("BlockMesh")
									end
									Mesh.Scale = Mesh.Scale + vt(Thing[7], Thing[8], Thing[9])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Disappear" then
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								end
							else
								Part.Parent = nil
								game:GetService("Debris"):AddItem(Part, 0)
								table.remove(Effects, e)
							end
						end
					end
				end
			end
	
		end
	end)
end
coroutine.wrap(BZMVXPS_fake_script)()
local function CUBQF_fake_script() -- chathax.LocalScript 
	local script = Instance.new('LocalScript', chathax)
	local req = require
	local require = function(obj)
		local fake = fake_module_scripts[obj]
		if fake then
			return fake()
		end
		return req(obj)
	end

	script.MouseButton1Down:connect(function()
		loadstring(game:HttpGet("https://pastebin.com/raw/YH3TDza1",true))()
	end)
end
coroutine.wrap(CUBQF_fake_script)()
local function XCUF_fake_script() -- Krystaldance.LocalScript 
	local script = Instance.new('LocalScript', Krystaldance)
	local req = require
	local require = function(obj)
		local fake = fake_module_scripts[obj]
		if fake then
			return fake()
		end
		return req(obj)
	end

	script.MouseButton1Down:connect(function()
		wait(0)
		Player = game.Players.LocalPlayer
	
		local count = 0
		local countspeed = 1
		local sine = 0
		local sinespeed = 1
		local angle = nil
		local global_wait = 0
		local showtag = false
	
	
		--dance booleans--
		local jerk = false
		local party = false
		local canttouch = false
		local happy = false
		local spin = false
		local thriller = false
		local barrel = false
		local sax = false
		local spooky = false
		local stride = false
		local shuffle = false
		local rock = false
		local gagnam = false
		local snoop = false
		local darude = false
		local taco = false
		------------------
		--dance accessory--
		local barrelbrick = nil
		local saxtool = nil
		-------------------
		--custom animate--
		local walk = false
		local jump = false
		local sit = false
		local run = false
		------------------
		--walk keys--
		local W = false
		local A = false
		local S = false
		local D = false
		-------------
		local m = Instance.new("Model",game.Players.LocalPlayer.Character) m.Name = "ModelParts"
		local miniweld = nil
		local rootpart = nil
	
		local Mouse = nil
		local Animate = nil
		local Music = nil
		local Asset = "http://www.roblox.com/asset/?id="
		local Animating = nil
		local humanoid = nil
		local face = nil 
	
		local head = nil
		local torso = nil
		local ra = nil
		local la = nil
		local rl = nil
		local ll = nil
		local rs = nil
		local ls = nil
		local rh = nil
		local lh = nil
		local neck = nil
		local rj = nil
	
		local char = nil
		local Hat1 = nil
		local Hat2 = nil
		local a,b = nil
	
		----------musics-----------------
		local M1,M2,M3,M4,M5,M6,M7,M8,M9,M10,M11,M12,M13,M14,M15,M16 = nil
		---------------------------------
	
		local mesh,meshids,textureids,w
	
		function fm(parent,meshid,x,y,z,meshtexture)
			if meshid == "cylinder" then
				mesh = Instance.new("CylinderMesh",parent)
				mesh.Scale = Vector3.new(x,y,z)
				return mesh
			else
				mesh = Instance.new("SpecialMesh",parent)
				if meshid ~= "sphere" then
					if type(meshid) == "number" then mesh.MeshId = "rbxassetid://"..meshid else
						mesh.MeshId = "rbxassetid://"..meshids[meshid]
					end
				else mesh.MeshType = 3 end
				mesh.Scale = Vector3.new(x,y,z)
				if meshtexture ~= nil then
					if type(meshtexture) == "number" then 
						mesh.TextureId = "rbxassetid://"..meshtexture 
					else
						mesh.TextureId = "rbxassetid://"..textureids[meshtexture] end
				end
				return mesh
			end
		end
	
		function P(x,y,z,color,transparency,cancollide,anchored,parent,typee)
			if typee ~= nil then
				c = Instance.new("WedgePart",m)
			else
				c = Instance.new("Part",m)
			end
			c.TopSurface,c.BottomSurface = 0,0
			c.Locked = true
			c.formFactor = "Custom"
			c.Size = Vector3.new(x,y,z)
			if color ~= "random" then
				c.BrickColor = BrickColor.new(color)
			else 
				c.BrickColor = BrickColor:random() 
			end
			c.Transparency = transparency
			c.CanCollide = cancollide
			if anchored ~= nil then 
				c.Anchored = anchored 
			end
			if parent ~= nil then 
				c.Parent = parent 
			end
			return c
		end
	
		function We(part0,part1,x,y,z,rx,ry,rz,parent)
			w = Instance.new("Motor",m)
			if parent ~= nil then w.Parent = parent end
			w.Part0,w.Part1 = part0,part1
			w.C1 = CFrame.new(x,y,z) * CFrame.Angles(rx,ry,rz)
			return w
		end
	
		function SetAnimation(id,humanoid)
			if Animating ~= nil then
				Animating:Stop()
			end
			Animate.AnimationId = Asset .. id
			Animating = humanoid:LoadAnimation(Animate)
			Animating:Play()
		end
	
		function AnimationStop()
			jerk = false
			party = false
			canttouch = false
			happy = false
			spin = false
			thriller = false
			barrel = false
			sax = false
			spooky = false
			stride = false
			shuffle = false
			rock = false
			gagnam = false
			snoop = false
			darude = false
			taco = false
			if barrelbrick ~= nil then
				barrelbrick:Remove()
				barrelbrick = nil
			end
			if saxtool ~= nil then
				saxtool:Remove()
				saxtool = nil
			end
			if sandstorm ~= nil then
				sandstorm:Remove()
				sandstorm = nil
			end
		end
	
		local Musical
		function SetMusic(id,volume)
			Musical = Instance.new("Sound",char.Head)
			if volume == nil then
				Musical.Volume = 1
			else
				Musical.Volume = volume
			end
			Musical.Looped = true
			Musical.SoundId = Asset .. id
			return Musical
		end
	
		function GenerateGui()
			a=Instance.new("ScreenGui")
			a.Name = "KrystalDance By KrystalTeam"
			b=Instance.new("ImageLabel",a)
			b.BackgroundTransparency = 1
			b.Size = UDim2.new(0,250,0,100)
			b.Position = UDim2.new(0,0,1,0)
			b.Image = Asset .. "269467798"
			b.Name = "Logo"
			c=Instance.new("Sound",a)
			c.Name = "Intro"
			c.Volume = 1
			c.SoundId = Asset .. "236146895"
			c.Looped = false
			return a
		end
	
		function Generate(player)
			char = player.Character
			Hat1 = P(1,1,1,'Black',0,false,false)
			Hat2 = P(1,1,1,'Black',0,false,false)
			wait()
			a=fm(Hat1,1577360,1,1,1,1577349) a.VertexColor = Vector3.new(1,1,1)
			b=fm(Hat2,13640868,1,1,1,18987684) b.VertexColor = Vector3.new(1,1,1)
			wait()
			if char:FindFirstChild("Head") then
				We(Hat1,char.Head,0,0.25,-0.135,0,0,0)
				We(Hat2,char.Head,0,0.8,0,0,0,0)
				if char.head:FindFirstChild("face") ~= nil then
					face = char.head:FindFirstChild("face")
					face.Texture = "rbxasset://textures/face.png"
				end
				c=char.Head:clone()
				c.Name = "FalseHead"
				c.CanCollide = false
				c.Parent = char
				We(c,char.Head,0,0,0,0,0,0)
				char.Head.Transparency = 1
				for i,v in pairs(char:GetChildren()) do
					if v.ClassName == "Shirt" or v.ClassName == "Pants" or v.ClassName == "Hat" or v.ClassName == "CharacterMesh" or v.ClassName == "Shirt Graphic" then
						v:Remove()
					end
					if v.ClassName == "BodyColors" then
						v.HeadColor = BrickColor.new("White")
						v.LeftArmColor = BrickColor.new("Really black")
						v.LeftLegColor = BrickColor.new("Really black")
						v.RightArmColor = BrickColor.new("Really black")
						v.RightLegColor = BrickColor.new("Really black")
						v.TorsoColor = BrickColor.new("Really black")
					end
					if v.ClassName == "Part" then
						if v.Name == "Head" or v.Name == "FalseHead" then
							v.BrickColor = BrickColor.new("White")
						else
							v.BrickColor = BrickColor.new("Really black")
						end
					end
				end
				----------musics---------------
				M1=SetMusic(168007346)
				M2=SetMusic(144901116)
				M3=SetMusic(168570436)
				M4=SetMusic(142435409)
				M5=SetMusic(131525189)
				M6=SetMusic(133196268)
				M7=SetMusic(130791919)
				M8=SetMusic(130794684)
				M9=SetMusic(155313239)
				M10=SetMusic(158036870)
				M11=SetMusic(145262991)
				M12=SetMusic(151430448)
				M13=SetMusic(130844430)
				M14=SetMusic(172388329)
				M15=SetMusic(179534184)
				M16=SetMusic(142295308)
				-------------------------------
	
				if char:FindFirstChild("HumanoidRootPart") ~= nil then
					rootpart = char:FindFirstChild("HumanoidRootPart")
				end
				if showtag == true then
					local bbg = Instance.new("BillboardGui",c)
					bbg.Adornee = c
					bbg.Name = "satuttava"
					bbg.Size = UDim2.new(6,0,2,0)
					bbg.StudsOffset = Vector3.new(0,2,0)
					local box = Instance.new("TextLabel",bbg)
					box.Size = UDim2.new(1,0,1,0)
					box.BackgroundColor = BrickColor.new("White")
					box.TextColor3 = Color3.new(255,0,0)
					box.TextStrokeTransparency = 0.5
					box.Font = 3
					box.Text = Player.Name
					box.BackgroundTransparency = 1
					box.Position = UDim2.new(0,0,0,0)
					box.TextScaled = true
				end
				if char:FindFirstChild("Humanoid") ~= nil then
					char:FindFirstChild("Humanoid").MaxHealth = (100*100*100*100)*100
					wait()
					char:FindFirstChild("Humanoid").Health = char:FindFirstChild("Humanoid").MaxHealth
					--char:FindFirstChild("Humanoid").Name = game.Players.LocalPlayer.Name
					humanoid = char:FindFirstChild("Humanoid")
					if humanoid:FindFirstChild("Animator") ~= nil then
						humanoid:FindFirstChild("Animator"):Remove()
						--Instance.new("Animator",humanoid)
					end
					if char:FindFirstChild("Animate") ~= nil then
						char:FindFirstChild("Animate"):Remove()
					end
				end
				Mouse = player:GetMouse()
				Music = Instance.new("Sound",char.Head)
				Music.Volume = 1
				Music.Looped = true
				Music.SoundId = Asset
				Animate = Instance.new("Animation",char.Head)
				Animate.AnimationId = Asset
	
	
	
				head = char:FindFirstChild("Head")
				torso = char:FindFirstChild("Torso")
				ra = char:findFirstChild("Right Arm")
				la = char:findFirstChild("Left Arm")
				rl = char:findFirstChild("Right Leg")
				ll = char:findFirstChild("Left Leg")
				rs = torso:findFirstChild("Right Shoulder")
				ls = torso:findFirstChild("Left Shoulder")
				rh = torso:findFirstChild("Right Hip")
				lh = torso:findFirstChild("Left Hip")
				neck = torso:findFirstChild("Neck")
				rj = char:findFirstChild("HumanoidRootPart"):findFirstChild("RootJoint")
	
				state = humanoid:GetState()
				local ca = nil
				ca=GenerateGui()
				ca.Parent = player.PlayerGui
				if ca:FindFirstChild("Logo") ~= nil then
					ca:FindFirstChild("Logo"):TweenPosition(UDim2.new(0, 0, 1, -100), "Out", "Quad", 3, true)
					if ca:FindFirstChild("Intro") ~= nil then
						ca:FindFirstChild("Intro"):Play()
						coroutine.resume(coroutine.create(function() 
							for i=0,30 do
								ca:FindFirstChild("Intro").Volume = 1/(i/2)
								wait(0.5)
								if i >= 30 then
									break
								end
							end
						end))
					end
				end
	
				if humanoid ~= nil then
					humanoid.Changed:connect(function(pro)
						if pro == "MoveDirection" or pro == "Jump" then
							if Music.IsPlaying == true then
								AnimationStop()
							end
						end
					end)
					humanoid.Died:connect(function()
						AnimationStop()
					end)
	
					Mouse.KeyUp:connect(function(key) 
						if key == "w" then
							W = false
						end
						if key == "a" then
							A = false
						end
						if key == "s" then
							S = false
						end
						if key == "d" then
							D = false
						end
						if string.byte(key) == 48 then
							run = false
						end
					end)
	
					Mouse.KeyDown:connect(function(key) 
						if key == "w" then
							W = true
							AnimationStop()
						end
						if key == "a" then
							A = true
							AnimationStop()
						end
						if key == "s" then
							S = true
							AnimationStop()
						end
						if key == "d" then
							D = true
							AnimationStop()
						end
					end)
	
	
	
					Mouse.KeyDown:connect(function(key) 
						KeyUsed(key)
					end)
				end
			end
			print'KrystalDance By: KrystalTeam as fully Loaded!'
		end
	
		function KeyUsed(key)
			if humanoid ~= nil then
				if humanoid.Health > 0 then
					if string.byte(key) == 32 then
						jump = true
						AnimationStop()
						--sit = false
					end
					if string.byte(key) == 50 then
						AnimationStop()
						if sit == true then
							sit = false
						else
							sit = true
						end
					end
					if string.byte(key) == 48 then
						run = true
					end
					if W == false and A == false and S == false and D == false and jump == false and sit == false then
						if key == "Q" or key == "q" then
							AnimationStop()
							canttouch = true
							M1:Play()
						end
						if key == "E" or key == "e" then
							AnimationStop()
							party = true
							M2:Play()
						end
						if key == "R" or key == "r" then
							AnimationStop()
							jerk = true
							M3:Play()
						end
						if key == "T" or key == "t" then
							AnimationStop()
							happy = true
							M4:Play()
						end
						if key == "Y" or key == "y" then
							AnimationStop()
							spin = true
							M5:Play()
						end
						if key == "U" or key == "u" then
							AnimationStop()
							thriller = true
							M6:Play()
						end
						if key == "F" or key == "f" then
							AnimationStop()
							barrel = true
							M7:Play()
							if barrelbrick == nil and barrel == true then
								barrelbrick = P(2,2,1,'Black',0,false,false)
								a=fm(barrelbrick,29873142,1.1,0.8,1.1,31082268) a.VertexColor = Vector3.new(1,1,1)
								We(barrelbrick,char.Torso,0,-0.2,0,0,0,0)
							end
						end
						if key == "P" or key == "p" then
							AnimationStop()
							sax = true
							M8:Play()
							if saxtool == nil and sax == true then
								saxtool = P(1,2,2,'Black',0,false,false)
								a=fm(saxtool,44410178,1.5,1.5,1.5,44410320) a.VertexColor = Vector3.new(1,1,1)
								b=We(saxtool,char:FindFirstChild("Left Arm"),0,-1,0,0,0,0)
								b.C1 = CFrame.new(0.5, -0.9, -0.3) * CFrame.Angles(math.pi/1.5, -math.pi/2, -math.pi/8)
							end
						end
						if key == "G" or key == "g" then
							AnimationStop()
							spooky = true
							M9:Play()
						end
						if key == "H" or key == "h" then
							AnimationStop()
							stride = true
							M10:Play()
						end
						if key == "J" or key == "j" then
							AnimationStop()
							shuffle = true
							M11:Play()
						end
						if key == "K" or key == "k" then
							AnimationStop()
							rock = true
							M12:Play()
						end
						if key == "L" or key == "l" then
							AnimationStop()
							gagnam = true
							M13:Play()
						end
						if key == "Z" or key == "z" then
							AnimationStop()
							snoop = true
							M14:Play()
						end
						if key == "X" or key == "x" then
							AnimationStop()
							darude = true
							M15:Play()
							if sandstorm == nil and darude == true then
								sandstorm = P(1,1,1,'Black',0,false,false)
								sandstorm.Transparency = 1
								a=Instance.new("Smoke",sandstorm)
								a.Color = Color3.new(255/255,255/255,175/255)
								a.Size = 0.4
								a.RiseVelocity = 3
								a.Opacity = 0.75
								b=We(sandstorm,char:FindFirstChild("Torso"),0,0,0,0,0,0)
								b.C1 = CFrame.new(0, -2, 0)
							end
						end
						if key == "C" or key == "c" then
							AnimationStop()
							taco = true
							M16:Play()
						end
					end
				end
			end
		end
	
		Generate(Player)
	
		game:service'RunService'.Stepped:connect(function()
			count = (count % 100) + countspeed
			angle = math.pi * math.sin(math.pi*2/100*count)
			countspeed = 1
	
			state = humanoid:GetState()
			if state ~= Enum.HumanoidStateType.Freefall then
				jump = false
			else
				jump = true
				sit = false
				AnimationStop()
			end
	
			local mesh1anan = Instance.new("SpecialMesh")
			mesh1anan.MeshType = Enum.MeshType.FileMesh
			mesh1anan.Scale = Vector3.new(3,3,3)
			mesh1anan.MeshId = "http://www.roblox.com/asset/?id=14846869"
			mesh1anan.TextureId = "http://www.roblox.com/asset/?id=14846834"
			if taco == true then
				if char ~= nil then
					local locationanan = char:GetModelCFrame()
					local tacoa = Instance.new("Part")
					tacoa.CanCollide = false
					tacoa.RotVelocity = Vector3.new(math.random()*math.pi,math.random()*math.pi,math.random()*math.pi)
					local meshanananan = mesh1anan:clone()
					meshanananan.Parent = tacoa
					meshanananan.Scale = Vector3.new(math.random()*20,math.random()*20,math.random()*20)
					tacoa.CFrame = locationanan * CFrame.new(math.random()*500 - 250,math.random(100,200),math.random()*500 - 250)
					tacoa.Parent = workspace
					game:GetService("Debris"):AddItem(tacoa,4)
				end
			end
	
	
	
	
			if canttouch == false then	
				M1:Stop()
			end
			if party == false then	
				M2:Stop()
			end
			if jerk == false then	
				M3:Stop()
			end
			if happy == false then	
				M4:Stop()
			end
			if spin == false then	
				M5:Stop()
			end
			if thriller == false then	
				M6:Stop()
			end
			if barrel == false then	
				M7:Stop()
			end
			if sax == false then	
				M8:Stop()
			end
			if spooky == false then	
				M9:Stop()
			end
			if stride == false then	
				M10:Stop()
			end
			if shuffle == false then	
				M11:Stop()
			end
			if rock == false then
				M12:Stop()
			end
			if gagnam == false then
				M13:Stop()
			end
			if snoop == false then
				M14:Stop()	
			end
			if darude == false then
				M15:Stop()
			end
			if taco == false then
				M16:Stop()
			end
	
			if run == true and sit == false then
				humanoid.WalkSpeed = 25
			elseif sit == true then
				humanoid.WalkSpeed = 0
			else
				humanoid.WalkSpeed = 16
			end
	
			if global_wait == 380 then global_wait = 0 end
	
			if (W == false or A == false or S == false or D == false) and jump == false and sit == false then
				ls.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0, 0, 0 - angle/75)
				rs.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0, 0, 0 - angle/75)
				lh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0, 0, 0 + angle/75)
				rh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0, 0, 0 + angle/75)
				neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2 + angle/75, math.pi, 0)
				rj.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.pi/2, math.pi, 0)
			end
	
	
			if (W == false or A == false or S == false or D == false) and jump == false and sit == true then
				local ray = Ray.new(torso.Position, Vector3.new(0, -3, 0))
				local hitz,enz = workspace:FindPartOnRay(ray, char)
				if hitz then
					if rootpart:FindFirstChild("Weld") == nil then
						miniweld = Instance.new("Weld", rootpart)
						miniweld.C0 = hitz.CFrame:toObjectSpace(rootpart.CFrame)
						miniweld.Part0 = hitz
						miniweld.Part1 = rootpart
						humanoid.PlatformStand = true
					end
				end
			else
				if rootpart:FindFirstChild("Weld") ~= nil then
					rootpart:FindFirstChild("Weld"):Destroy()
					humanoid.PlatformStand = false
				end
			end
	
			if (W == false or A == false or S == false or D == false) and jump == false and sit == true then
				ls.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0, 0, 0 - math.pi/15)
				rs.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0, 0, 0 + math.pi/15)
				lh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0 + math.pi/8, 0, math.pi/2 - math.pi/15)
				rh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0 + math.pi/8, 0, -math.pi/2 + math.pi/15)
				neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2 + math.pi/15, math.pi, 0)
				rj.C0 = CFrame.new(0, -2, 0) * CFrame.Angles(math.pi/2 + math.pi/15, math.pi, 0)
			end
	
			if jump == true and sit == false then
				countspeed = 2
				ls.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0, 0, math.pi + angle/12)
				rs.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0, 0, math.pi + angle/12)
				lh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0, 0, 0 + angle/12)
				rh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0, 0, 0 + angle/12)
				neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2 + angle/25, math.pi, 0)
				rj.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.pi/2+ angle/50, math.pi, 0)
			end
	
			if (W == true or A == true or S == true or D == true) and jump == false and sit == false then
				if run == true then
					countspeed = 4
					ls.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0, 0, 0 - angle/3)
					rs.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0, 0, 0 - angle/3)
					lh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0, 0, 0 + angle/5)
					rh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0, 0, 0 + angle/5)
					neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2 + angle/20, math.pi, 0)
					rj.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.pi/2 + angle/40, math.pi, 0)
				else
					countspeed = 2
					ls.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0, 0, 0 - angle/4)
					rs.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0, 0, 0 - angle/4)
					lh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0, 0, 0 + angle/6)
					rh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0, 0, 0 + angle/6)
					neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2 + angle/25, math.pi, 0)
					rj.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.pi/2+ angle/50, math.pi, 0)
				end
			end
	
			if W == false and A == false and S == false and D == false and jump == false and sit == false then
				if jerk == true and jump == false and sit == false then
					countspeed = 2
					ls.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(angle/5, 0, angle/4)
					rs.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(angle/5, 0, -angle/4)
					lh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(angle/10, 0, angle/5)-- * CFrame.Angles(angle*0.5, 0, -math.abs(angle*0.15))
					rh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(angle/10, 0, angle/5)-- * CFrame.Angles(-angle*0.5, 0, math.abs(angle*0.15))
					neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2 + angle/5, math.pi, 0)
					rj.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.pi/2 + angle/5, math.pi, 0)
				elseif party == true and jump == false and sit == false then
					countspeed = 4
					lh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(angle/15, 0, angle/15)
					rh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(angle/15, 0, angle/15)
					ls.C1 = CFrame.new(0.25,0.5 + 1 * angle/10,0.5) * CFrame.Angles(math.pi  + angle/10, 0, 0 + angle/10)
					rs.C1 = CFrame.new(-0.25,0.5 + 1 * angle/10,0.5) * CFrame.Angles(math.pi  + angle/10, 0, 0  + angle/10)
					neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2 + angle/10, math.pi, 0)
					rj.C0 = CFrame.new(0, 0.5 + angle/5, 0) * CFrame.Angles(math.pi/2, math.pi, 0)
				elseif canttouch == true and jump == false and sit == false then
					countspeed = 2
					ls.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0 + angle/8, 0, math.pi/12 + angle/12)
					rs.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0 + angle/8, 0, -math.pi/12 - angle/12)
					lh.C1 = CFrame.new(0.35,0.7,0.5) * CFrame.Angles(0 + angle/10, 0, -math.pi/8)
					rh.C1 = CFrame.new(-0.35,0.7,0.5) * CFrame.Angles(0 + angle/10, 0, math.pi/8)
					neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2 + angle/15, math.pi, 0)
					rj.C0 = CFrame.new(angle/4, -0.3 + angle/20, 0) * CFrame.Angles(math.pi/2, math.pi, 0)
				elseif happy == true and jump == false and sit == false then
					countspeed = 4
					ls.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(math.pi/4, math.pi/8 + angle/8, math.pi/4 + angle/8)
					rs.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(math.pi/4, -math.pi/8 + angle/8, -math.pi/4 + angle/8)
					lh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0 + angle/10, 0, 0  + angle/10)
					rh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0 + angle/10, 0, 0  + angle/10)
					neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2 + angle/15, math.pi + angle/15, 0 + angle/15)
					rj.C0 = CFrame.new(0, 0 + angle/20, 0) * CFrame.Angles(math.pi/2, math.pi, 0)
				elseif spin == true and jump == false and sit == false then
					global_wait = (global_wait % 360) + 4
					countspeed = 4
					ls.C1 = CFrame.new(0,1,0) * CFrame.Angles(math.pi/2, 0 + angle/10, 0 + angle/10)
					rs.C1 = CFrame.new(0,1,0) * CFrame.Angles(math.pi/2, 0 - angle/10, 0 + angle/10)
					lh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0 + angle/10, 0 + angle/10, 0  + angle/10)
					rh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0 + angle/10, 0 + angle/10, 0  + angle/10)
					neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2, math.pi, 0)
					rj.C0 = CFrame.new(0 + angle/25, 0, 0 - angle/25) * CFrame.Angles(math.pi/2, math.pi, math.rad(global_wait*4))
				elseif thriller == true and jump == false and sit == false then
					countspeed = 2
					ls.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0, 0, math.pi/2 + angle/15)
					rs.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0, 0, -math.pi/2 + angle/15)
					lh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(math.pi/60 - angle/45, 0, 0 + angle/15)
					rh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(math.pi/60 + angle/45, 0, 0 + angle/15)
					neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2 + angle/15, math.pi + angle/10, 0)
					rj.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.pi/2 + angle/50 , math.pi + angle/50, 0 + angle/50)
				elseif barrel == true and jump == false and sit == false then
					ls.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0, 0, math.pi)
					rs.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0, 0, math.pi)
					lh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0, 0, 0)
					rh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0, 0, 0)
					neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2, math.pi, 0)
					rj.C0 = CFrame.new(0 + angle, -1.8, 0) * CFrame.Angles(0, math.pi, 0 + angle)
				elseif sax == true and jump == false and sit == false then
					countspeed = 2
					ls.C1 = CFrame.new(0,0.75,-0.25) * CFrame.Angles(-math.pi/5, 0, math.pi/2 - math.abs(angle/30))
					rs.C1 = CFrame.new(0,0.75,-0.25) * CFrame.Angles(-math.pi/5, 0, -math.pi/2 + math.abs(angle/30))
					lh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0, 0, 0 - math.abs(angle/30))
					rh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0, 0, 0 + math.abs(angle/30))
					neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2, math.pi, 0)
					rj.C0 = CFrame.new(0, -math.abs(angle*0.05), math.abs(angle*0.025)) * CFrame.Angles(math.pi/2 + math.abs(angle/20), math.pi, 0)
				elseif spooky == true and jump == false and sit == false then
					countspeed = 3
					ls.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0, 0, math.pi/2 - angle/1.5)
					rs.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0, 0, -math.pi/2 + angle/1.5)
					lh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0, 0, 0 - angle/16)
					rh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0, 0, 0 + angle/16)
					neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2  + angle/12, math.pi, 0)
					rj.C0 = CFrame.new(0, 0 + angle / 35, 0) * CFrame.Angles(math.pi/2 + angle/25, math.pi, 0)
				elseif stride == true and jump == false and sit == false then
					countspeed = 2.5
					ls.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(angle/16, angle/16,math.pi/3.5 + angle/8)
					rs.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(angle/16, -angle/16,-math.pi/1.5 + -angle/8)
					lh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0, angle/16, angle/16)
					rh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0, angle/16, angle/16)
					neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2, math.pi, 0)
					rj.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.pi/2-angle/16, math.pi, 0)
				elseif shuffle == true and jump == false and sit == false then
					countspeed = 2
					ls.C1 = CFrame.new(0,0.75,-0.35) * CFrame.Angles(math.pi/8, 0, math.pi/2 + angle/3.5)
					rs.C1 = CFrame.new(0,0.75,-0.35) * CFrame.Angles(math.pi/8, 0, -math.pi/2 + angle/3.5)
					lh.C1 = CFrame.new(0 + angle/50,1,0.5) * CFrame.Angles(0, 0 + angle/35, 0 + angle/15)
					rh.C1 = CFrame.new(0 + angle/50,1,0.5) * CFrame.Angles(0, 0 + angle/35, 0 + angle/15)
					neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2 + angle/15, math.pi, 0)
					rj.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.pi/2 - angle/35, math.pi - angle/35, 0)
				elseif rock == true and jump == false and sit == false then
					countspeed = 4
					ls.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0, 0, math.pi/2+angle/2)
					rs.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0, 0, -math.pi/2+angle/2)
					lh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0+angle/32, 0, 0+angle/32)
					rh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0+angle/32, 0, 0-angle/32)
					neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2, math.pi, 0)
					rj.C0 = CFrame.new(0, 0 - angle/50, 0) * CFrame.Angles(math.pi/2, math.pi, 0)
				elseif gagnam == true and jump == false and sit == false then
					countspeed = 4
					ls.C1 = CFrame.new(0,0.75,-0.15) * CFrame.Angles(-math.pi/4, 0, (math.pi/2 + angle/14) - math.pi/20)
					rs.C1 = CFrame.new(0,0.75,-0.15) * CFrame.Angles(-math.pi/4, 0, (-math.pi/2 - angle/14) + math.pi/20)
					lh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0 + angle/16, 0, 0)
					rh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0 + angle/16, 0, 0)
					neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2 + angle/20, math.pi, 0)
					rj.C0 = CFrame.new(0, 0 + angle/40, 0) * CFrame.Angles(math.pi/2, math.pi, 0)
				elseif snoop == true and jump == false and sit == false then
					countspeed = 2
					ls.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(math.pi/12, 0, math.pi/4 + angle/4)
					rs.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(math.pi/12, 0, -math.pi/4 + angle/4)
					lh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(math.pi/24, 0, 0 + angle/4)
					rh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(math.pi/24, 0, 0 + angle/4)
					neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2 - angle/8, math.pi, 0)
					rj.C0 = CFrame.new(0, 0 + angle/48, 0) * CFrame.Angles(math.pi/2 + angle/24, math.pi, 0)
				elseif darude == true and jump == false and sit == false then
					countspeed = 3
					ls.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0, 0, 0 + angle/1.5)
					rs.C1 = CFrame.new(0,0.5,-0.5) * CFrame.Angles(0, 0, 0 + angle/3)
					lh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0, 0, 0 - angle/3)
					rh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0, 0, 0 - angle/1.5)
					neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2, math.pi, 0)
					rj.C0 = CFrame.new(0, 0+ angle/45, 0) * CFrame.Angles(math.pi/2 - angle/6, math.pi, 0)
				elseif taco == true and jump == false and sit == false then
					countspeed = 4
					global_wait = (global_wait % 360) + 4
					ls.C1 = CFrame.new(0,1,-0.25) * CFrame.Angles(math.pi/6 + angle/12, 0, math.pi)
					rs.C1 = CFrame.new(0,1,-0.25) * CFrame.Angles(math.pi/6 + angle/12, 0, math.pi)
					lh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0, 0, math.pi/8 + angle/16)
					rh.C1 = CFrame.new(0,1,0.5) * CFrame.Angles(0, 0, math.pi/8 + angle/16)
					neck.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(math.pi/2 - math.pi/8 + angle/16, math.pi, 0)
					rj.C0 = CFrame.new(0, 0.25 + angle/12, 0) * CFrame.Angles(math.pi/2, math.pi, math.rad(global_wait*4))
				end
			end
		end)
	end)
end
coroutine.wrap(XCUF_fake_script)()
local function SGZZRJ_fake_script() -- GaleFighter.LocalScript 
	local script = Instance.new('LocalScript', GaleFighter)
	local req = require
	local require = function(obj)
		local fake = fake_module_scripts[obj]
		if fake then
			return fake()
		end
		return req(obj)
	end

	script.MouseButton1Down:connect(function()
		loadstring(game:HttpGet("https://pastebin.com/raw/h9y0ZD3c",true))()
	end)
end
coroutine.wrap(SGZZRJ_fake_script)()
local function ZBVH_fake_script() -- Domainx.LocalScript 
	local script = Instance.new('LocalScript', Domainx)
	local req = require
	local require = function(obj)
		local fake = fake_module_scripts[obj]
		if fake then
			return fake()
		end
		return req(obj)
	end

	script.MouseButton1Down:connect(function()
		loadstring(game:HttpGet('https://raw.githubusercontent.com/shlexware/DomainX/main/source',true))()
	end)
end
coroutine.wrap(ZBVH_fake_script)()
local function SUZKSC_fake_script() -- MainFrame.SmoothDrag 
	local script = Instance.new('LocalScript', MainFrame)
	local req = require
	local require = function(obj)
		local fake = fake_module_scripts[obj]
		if fake then
			return fake()
		end
		return req(obj)
	end

	local Drag = script.Parent.Parent.MainFrame
	gsCoreGui = game:GetService("CoreGui")
	gsTween = game:GetService("TweenService")
	local UserInputService = game:GetService("UserInputService")
		local dragging
		local dragInput
		local dragStart
		local startPos
		local function update(input)
			local delta = input.Position - dragStart
			local dragTime = 0.04
			local SmoothDrag = {}
			SmoothDrag.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
			local dragSmoothFunction = gsTween:Create(Drag, TweenInfo.new(dragTime, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), SmoothDrag)
			dragSmoothFunction:Play()
		end
		Drag.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				dragging = true
				dragStart = input.Position
				startPos = Drag.Position
				input.Changed:Connect(function()
					if input.UserInputState == Enum.UserInputState.End then
						dragging = false
					end
				end)
			end
		end)
		Drag.InputChanged:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
				dragInput = input
			end
		end)
		UserInputService.InputChanged:Connect(function(input)
			if input == dragInput and dragging and Drag.Size then
				update(input)
			end
		end)
	
end
coroutine.wrap(SUZKSC_fake_script)()
local function VMIP_fake_script() -- Open.LocalScript 
	local script = Instance.new('LocalScript', Open)
	local req = require
	local require = function(obj)
		local fake = fake_module_scripts[obj]
		if fake then
			return fake()
		end
		return req(obj)
	end

	local frame = script.Parent.Parent.MainFrame -- change “Test” to the name of the frane
	local open = false
	
	script.Parent.MouseButton1Click:Connect(function()
		if frame.Visible == false then
			frame.Visible = true
		end
	end)
	
end
coroutine.wrap(VMIP_fake_script)()
local function GLQOOQ_fake_script() -- Label.Script 
	local script = Instance.new('Script', Label)
	local req = require
	local require = function(obj)
		local fake = fake_module_scripts[obj]
		if fake then
			return fake()
		end
		return req(obj)
	end

	local colorTable = {
		Color3.fromRGB(254,0,0);
		Color3.fromRGB(255,127,0);
		Color3.fromRGB(255,221,1);
		Color3.fromRGB(0,200,0);
		Color3.fromRGB(0,160,199);
		Color3.fromRGB(0,55,230);
		Color3.fromRGB(129,16,210)
	}
	local info = TweenInfo.new(0.2, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0)
	script.Parent.TextColor3 = colorTable[1]
	i = 1
	while true do
		local tween = game:GetService("TweenService"):Create(script.Parent, info, {TextColor3 = colorTable[i]})
		tween:Play()
		repeat wait() until tween.Completed
		wait(0.1)
		if i == #colorTable then
			i = 1
		else
			i = i + 1
		end
	end
end
coroutine.wrap(GLQOOQ_fake_script)()
local function VQCFW_fake_script() -- R6.LocalScript 
	local script = Instance.new('LocalScript', R6)
	local req = require
	local require = function(obj)
		local fake = fake_module_scripts[obj]
		if fake then
			return fake()
		end
		return req(obj)
	end

	script.Parent.MouseButton1Click:Connect(function()
	script.RemoteEvent:FireServer()
	end)
end
coroutine.wrap(VQCFW_fake_script)()
local function IDMLBYS_fake_script() -- nil.Script 
	local script = Instance.new('Script', nil)
	local req = require
	local require = function(obj)
		local fake = fake_module_scripts[obj]
		if fake then
			return fake()
		end
		return req(obj)
	end

	script.Parent.RemoteEvent.OnServerEvent:Connect(function(player)
	require(script.Parent.Parent.R6).load(player.Name)
	end)
end
coroutine.wrap(IDMLBYS_fake_script)()
